//------------------------------------------------------------------------------
//  noninterleaved.zig
//
//  How to use non-interleaved vertex data (vertex components in
//  separate non-interleaved chunks in the same vertex buffers). Note
//  that only 4 separate chunks are currently possible because there
//  are 4 vertex buffer bind slots in sg_bindings, but you can keep
//  several related vertex components interleaved in the same chunk.
//------------------------------------------------------------------------------
const sokol = @import("sokol");
const slog = sokol.log;
const sg = sokol.gfx;
const sapp = sokol.app;
const sgapp = sokol.app_gfx_glue;
const vec3 = @import("math.zig").Vec3;
const mat4 = @import("math.zig").Mat4;
const shd = @import("shaders/noninterleaved.glsl.zig");

const state = struct {
    var rx: f32 = 0.0;
    var ry: f32 = 0.0;
    var pip: sg.Pipeline = .{};
    var bind: sg.Bindings = .{};
    var pass_action: sg.PassAction = .{};
    // the view matrix doesn't change
    const view: mat4 = mat4.lookat(.{ .x = 0.0, .y = 1.5, .z = 6.0 }, vec3.zero(), vec3.up());
};

export fn init() void {
    sg.setup(.{
        .context = sgapp.context(),
        .logger = .{ .func = slog.func },
    });

    // cube vertex buffer, NOTE how the vertex components are separate
    const vbuf = sg.makeBuffer(.{
        .data = sg.asRange(&[_]f32{
            // positions
            -1.0, -1.0, -1.0, 1.0,  -1.0, -1.0, 1.0,  1.0,  -1.0, -1.0, 1.0,  -1.0,
            -1.0, -1.0, 1.0,  1.0,  -1.0, 1.0,  1.0,  1.0,  1.0,  -1.0, 1.0,  1.0,
            -1.0, -1.0, -1.0, -1.0, 1.0,  -1.0, -1.0, 1.0,  1.0,  -1.0, -1.0, 1.0,
            1.0,  -1.0, -1.0, 1.0,  1.0,  -1.0, 1.0,  1.0,  1.0,  1.0,  -1.0, 1.0,
            -1.0, -1.0, -1.0, -1.0, -1.0, 1.0,  1.0,  -1.0, 1.0,  1.0,  -1.0, -1.0,
            -1.0, 1.0,  -1.0, -1.0, 1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  -1.0,
            // colors
            1.0,  0.5,  0.0,  1.0,  1.0,  0.5,  0.0,  1.0,  1.0,  0.5,  0.0,  1.0,
            1.0,  0.5,  0.0,  1.0,  0.5,  1.0,  0.0,  1.0,  0.5,  1.0,  0.0,  1.0,
            0.5,  1.0,  0.0,  1.0,  0.5,  1.0,  0.0,  1.0,  0.5,  0.0,  1.0,  1.0,
            0.5,  0.0,  1.0,  1.0,  0.5,  0.0,  1.0,  1.0,  0.5,  0.0,  1.0,  1.0,
            1.0,  0.5,  1.0,  1.0,  1.0,  0.5,  1.0,  1.0,  1.0,  0.5,  1.0,  1.0,
            1.0,  0.5,  1.0,  1.0,  0.5,  1.0,  1.0,  1.0,  0.5,  1.0,  1.0,  1.0,
            0.5,  1.0,  1.0,  1.0,  0.5,  1.0,  1.0,  1.0,  1.0,  1.0,  0.5,  1.0,
            1.0,  1.0,  0.5,  1.0,  1.0,  1.0,  0.5,  1.0,  1.0,  1.0,  0.5,  1.0,
        }),
    });

    // cube index buffer
    const ibuf = sg.makeBuffer(.{
        .type = .INDEXBUFFER,
        .data = sg.asRange(&[_]u16{
            0,  1,  2,  0,  2,  3,
            6,  5,  4,  7,  6,  4,
            8,  9,  10, 8,  10, 11,
            14, 13, 12, 15, 14, 12,
            16, 17, 18, 16, 18, 19,
            22, 21, 20, 23, 22, 20,
        }),
    });

    // shader and pipeline object
    var pip_desc: sg.PipelineDesc = .{
        .shader = sg.makeShader(shd.noninterleavedShaderDesc(sg.queryBackend())),
        .index_type = .UINT16,
        .cull_mode = .BACK,
        .depth = .{
            .compare = .LESS_EQUAL,
            .write_enabled = true,
        },
    };
    // NOTE how the vertex components are pulled from different buffer bind slots
    pip_desc.layout.attrs[shd.ATTR_vs_position] = .{ .format = .FLOAT3, .buffer_index = 0 };
    pip_desc.layout.attrs[shd.ATTR_vs_color0] = .{ .format = .FLOAT4, .buffer_index = 1 };
    state.pip = sg.makePipeline(pip_desc);

    // fill the resource bindings, note how the same vertex
    // buffer is bound to the first two slots, and the vertex-buffer-offsets
    // are used to point to the position- and color-components.
    state.bind.vertex_buffers[0] = vbuf;
    state.bind.vertex_buffers[1] = vbuf;
    // position vertex components are at the start of the buffer
    state.bind.vertex_buffer_offsets[0] = 0;
    // color vertex components follow after the positions
    state.bind.vertex_buffer_offsets[1] = 24 * 3 * @sizeOf(f32);
    state.bind.index_buffer = ibuf;
}

export fn frame() void {
    const dt = @as(f32, @floatCast(sapp.frameDuration() * 60));
    state.rx += 1.0 * dt;
    state.ry += 2.0 * dt;
    const vs_params = computeVsParams(state.rx, state.ry);

    sg.beginDefaultPass(.{}, sapp.width(), sapp.height());
    sg.applyPipeline(state.pip);
    sg.applyBindings(state.bind);
    sg.applyUniforms(.VS, shd.SLOT_vs_params, sg.asRange(&vs_params));
    sg.draw(0, 36, 1);
    sg.endPass();
    sg.commit();
}

export fn cleanup() void {
    sg.shutdown();
}

pub fn main() void {
    sapp.run(.{
        .init_cb = init,
        .frame_cb = frame,
        .cleanup_cb = cleanup,
        .width = 800,
        .height = 600,
        .sample_count = 4,
        .icon = .{ .sokol_default = true },
        .logger = .{ .func = slog.func },
        .window_title = "noninterleaved.zig",
    });
}

fn computeVsParams(rx: f32, ry: f32) shd.VsParams {
    const rxm = mat4.rotate(rx, .{ .x = 1.0, .y = 0.0, .z = 0.0 });
    const rym = mat4.rotate(ry, .{ .x = 0.0, .y = 1.0, .z = 0.0 });
    const model = mat4.mul(rxm, rym);
    const aspect = sapp.widthf() / sapp.heightf();
    const proj = mat4.persp(60.0, aspect, 0.01, 10.0);
    return shd.VsParams{ .mvp = mat4.mul(mat4.mul(proj, state.view), model) };
}
